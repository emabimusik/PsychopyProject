ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cVlad Ilie\u005cDocuments\u005cDemosPsyschopy\u005cpsychophysicsStaircase\u005cdata\u005cs_001_2016_maj_13_0947
p8
sS'runtimeInfo'
p9
NsS'name'
p10
VpsychophysicsStaircase
p11
sS'dataNames'
p12
(lp13
S'ready.keys'
p14
aS'ready.rt'
p15
asS'autoLog'
p16
I01
sS'extraInfo'
p17
(dp18
S'date'
p19
V2016_maj_13_0947
p20
sS'frameRate'
p21
cnumpy.core.multiarray
scalar
p22
(cnumpy
dtype
p23
(S'f8'
I0
I1
tRp24
(I3
S'<'
NNNI-1
I-1
I0
tbS'n+\x19\xd4\x8e\xc7R@'
tRp25
sS'expName'
p26
g11
sS'participant'
p27
Vs_001
p28
sS'ori'
p29
I10
ssS'loopsUnfinished'
p30
(lp31
g1
(cpsychopy.data
StairHandler
p32
g3
NtRp33
(dp34
S'origin'
p35
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.70.01), maj 13, 2016, at 09:45\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'psychophysicsStaircase'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'s_001', 'ori':10}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(3440, 1440), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instr"\u000ainstrClock = core.Clock()\u000ainstructions = visual.TextStim(win=win, ori=0, name='instructions',\u000a    text="This experiment measures your detection threshold using a staircase procedure.\u005cn\u005cnPress 'up' if you see the stimulus, 'down' if you do not see.\u005cn\u005cnAny key to start",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1, 1, 1], colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000afixation = visual.GratingStim(win=win, name='fixation',units='pix', \u000a    tex=None, mask=None,\u000a    ori=0, pos=[0, 0], size=[3, 3], sf=1, phase=0.0,\u000a    color=[1, 1, 1], colorSpace='rgb', opacity=1,\u000a    texRes=128, interpolate=True, depth=0.0)\u000agabor = visual.GratingStim(win=win, name='gabor',units='pix', \u000a    tex='sin', mask='gauss',\u000a    ori=expInfo['ori'], pos=[0, 0], size=[128,128], sf=0.1, phase=1.0,\u000a    color=1.0, colorSpace='rgb', opacity=1,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr"-------\u000at = 0\u000ainstrClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aready = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aready.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrComponents = []\u000ainstrComponents.append(instructions)\u000ainstrComponents.append(ready)\u000afor thisComponent in instrComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instructions* updates\u000a    if t >= 0 and instructions.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instructions.tStart = t  # underestimates by a little under one frame\u000a        instructions.frameNStart = frameN  # exact frame index\u000a        instructions.setAutoDraw(True)\u000a    \u000a    # *ready* updates\u000a    if t >= 0 and ready.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ready.tStart = t  # underestimates by a little under one frame\u000a        ready.frameNStart = frameN  # exact frame index\u000a        ready.status = STARTED\u000a        # keyboard checking is just starting\u000a        ready.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ready.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ready.keys = theseKeys[-1]  # just the last key pressed\u000a            ready.rt = ready.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instr"-------\u000afor thisComponent in instrComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ready.keys in ['', [], None]:  # No response was made\u000a   ready.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ready.keys',ready.keys)\u000aif ready.keys != None:  # we had a response\u000a    thisExp.addData('ready.rt', ready.rt)\u000athisExp.nextEntry()\u000a# the Routine "instr" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#--------Prepare to start Staircase "trials" --------\u000a# set up handler to look after next chosen value etc\u000atrials = data.StairHandler(startVal=0.5, extraInfo=expInfo,\u000a    stepSizes=asarray([0.8,0.8,0.4,0.4,0.2]), stepType='log',\u000a    nReversals=0, nTrials=30.0, \u000a    nUp=1, nDown=3,\u000a    minVal=0.0, maxVal=1.0,\u000a    originPath=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experimentlevel = thisTrial = 0.5  # initialise some vals\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    level = thisTrial\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    gabor.setColor([level, level, level], colorSpace='rgb')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation)\u000a    trialComponents.append(gabor)\u000a    trialComponents.append(resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation* updates\u000a        if t >= 0.0 and fixation.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation.tStart = t  # underestimates by a little under one frame\u000a            fixation.frameNStart = frameN  # exact frame index\u000a            fixation.setAutoDraw(True)\u000a        if fixation.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            fixation.setAutoDraw(False)\u000a        \u000a        # *gabor* updates\u000a        if t >= 0.5 and gabor.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            gabor.tStart = t  # underestimates by a little under one frame\u000a            gabor.frameNStart = frameN  # exact frame index\u000a            gabor.setAutoDraw(True)\u000a        if gabor.status == STARTED and t >= (0.5 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            gabor.setAutoDraw(False)\u000a        if gabor.status == STARTED:  # only update if being drawn\u000a            gabor.setPhase(trialClock.getTime()*2, log=False)\u000a        \u000a        # *resp* updates\u000a        if t >= 0.5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (0.5 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str('up')) or (resp.keys == 'up'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str('up').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (StairHandler)\u000a    trials.addResponse(resp.corr)\u000a    trials.addOtherData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# staircase completed\u000a\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials')\u000awin.close()\u000acore.quit()\u000a
p36
sS'nDown'
p37
I3
sS'_exp'
p38
I84396368
sS'reversalIntensities'
p39
(lp40
sS'stepSizes'
p41
cnumpy.core.multiarray
_reconstruct
p42
(cnumpy
ndarray
p43
(I0
tS'b'
tRp44
(I1
(I5
tg24
I00
S'\x9a\x99\x99\x99\x99\x99\xe9?\x9a\x99\x99\x99\x99\x99\xe9?\x9a\x99\x99\x99\x99\x99\xd9?\x9a\x99\x99\x99\x99\x99\xd9?\x9a\x99\x99\x99\x99\x99\xc9?'
tbsS'nUp'
p45
I1
sS'startVal'
p46
F0.5
sS'_nextIntensity'
p47
F0.5
sS'_warnUseOfNext'
p48
I01
sS'method'
p49
S'2AFC'
p50
sS'maxVal'
p51
F1
sS'stepSizeCurrent'
p52
g22
(g24
S'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp53
sS'correctCounter'
p54
I0
sS'nReversals'
p55
I5
sS'minVal'
p56
F0
sS'otherData'
p57
(dp58
sS'finished'
p59
I00
sS'stepType'
p60
S'log'
p61
sS'data'
p62
(lp63
sS'reversalPoints'
p64
(lp65
sg6
S'C:\\Users\\Vlad Ilie\\Documents\\DemosPsyschopy\\psychophysicsStaircase\\psychophysicsStaircase.py'
p66
sg10
S'trials'
p67
sg17
g18
sS'currentDirection'
p68
S'start'
p69
sS'_variableStep'
p70
I01
sS'intensities'
p71
(lp72
F0.5
asS'initialRule'
p73
I0
sS'nTrials'
p74
F30
sS'thisTrialN'
p75
I0
sg16
I01
sbasS'saveWideText'
p76
I01
sS'thisEntry'
p77
(dp78
sS'version'
p79
S''
sS'_paramNamesSoFar'
p80
(lp81
sS'entries'
p82
(lp83
(dp84
g26
g11
sg27
g28
sg15
F22.163483693318085
sg19
g20
sg14
S'escape'
p85
sg21
g25
sg29
I10
sasS'loops'
p86
(lp87
g33
asS'savePickle'
p88
I00
sb.