ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cVlad Ilie\u005cDocuments\u005cDemosPsyschopy\u005cpsychophysicsStaircase\u005cdata\u005cs_001_kasper_2016_maj_27_1000
p8
sS'runtimeInfo'
p9
NsS'name'
p10
VpsychophysicsStaircase
p11
sS'dataNames'
p12
(lp13
S'ready.keys'
p14
aS'ready.rt'
p15
aS'trials.response'
p16
aS'resp.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_maj_27_1000
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'.l\x0c\x83s\xbaR@'
tRp27
sS'expName'
p28
g11
sS'participant'
p29
Vs_001_kasper
p30
sS'ori'
p31
I10
ssS'loopsUnfinished'
p32
(lp33
sS'saveWideText'
p34
I01
sS'thisEntry'
p35
(dp36
sS'version'
p37
S''
sS'_paramNamesSoFar'
p38
(lp39
sS'entries'
p40
(lp41
(dp42
g28
g11
sg29
g30
sg15
F74.636022670948478
sg21
g22
sg14
S'space'
p43
sg23
g27
sg31
I10
sa(dp44
g29
g30
sS'trials.stepSize'
p45
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp46
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p47
I0
sg16
I0
sg21
g22
sS'trials.intensity'
p48
F0.5
sg17
(lp49
sa(dp50
g29
g30
sS'trials.stepSize'
p51
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p53
I1
sS'trials.response'
p54
I1
sg21
g22
sS'trials.intensity'
p55
F1
sg17
F0.25378367331904883
sa(dp56
g29
g30
sS'trials.stepSize'
p57
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p58
I2
sS'trials.response'
p59
I1
sg21
g22
sS'trials.intensity'
p60
g24
(g26
S't\xb3v\xc5`I\xc4?'
tRp61
sg17
F0.49393048630372505
sa(dp62
g29
g30
sS'trials.stepSize'
p63
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p64
I3
sS'trials.response'
p65
I1
sg21
g22
sS'trials.intensity'
p66
g61
sg17
F0.34714798963796056
sa(dp67
g29
g30
sS'trials.stepSize'
p68
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p69
I4
sS'trials.response'
p70
I1
sg21
g22
sS'trials.intensity'
p71
g61
sg17
F0.33376922022762301
sa(dp72
g29
g30
sS'trials.stepSize'
p73
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p74
I5
sS'trials.response'
p75
I1
sg21
g22
sS'trials.intensity'
p76
g24
(g26
S'\xdd\xe6\xfbr\xc2\xb8\x99?'
tRp77
sg17
F0.41390267889255483
sa(dp78
g29
g30
sS'trials.stepSize'
p79
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p80
I6
sS'trials.response'
p81
I1
sg21
g22
sS'trials.intensity'
p82
g77
sg17
F0.40322737417955068
sa(dp83
g29
g30
sS'trials.stepSize'
p84
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p85
I7
sS'trials.response'
p86
I1
sg21
g22
sS'trials.intensity'
p87
g77
sg17
F0.40061476956270781
sa(dp88
g29
g30
sS'trials.stepSize'
p89
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p90
I8
sS'trials.response'
p91
I1
sg21
g22
sS'trials.intensity'
p92
g24
(g26
S'\x84\xees\xcctNp?'
tRp93
sg17
F0.69582097968304879
sa(dp94
g29
g30
sS'trials.stepSize'
p95
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p96
I9
sS'trials.response'
p97
I1
sg21
g22
sS'trials.intensity'
p98
g93
sg17
F0.5605807317460858
sa(dp99
g29
g30
sS'trials.stepSize'
p100
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p101
I10
sS'trials.response'
p102
I1
sg21
g22
sS'trials.intensity'
p103
g93
sg17
F0.56066042297970853
sa(dp104
g29
g30
sS'trials.stepSize'
p105
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xd9?'
tRp106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p107
I11
sS'trials.response'
p108
I0
sg21
g22
sS'trials.intensity'
p109
g24
(g26
S'd}q\x94\xda\xacD?'
tRp110
sg17
F1.187563579415837
sa(dp111
g29
g30
sS'trials.stepSize'
p112
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p113
I12
sS'trials.response'
p114
I1
sg21
g22
sS'trials.intensity'
p115
g24
(g26
S'\x9b7y\x1b\x86\xf7Y?'
tRp116
sg17
F0.93428582468095556
sa(dp117
g29
g30
sS'trials.stepSize'
p118
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p119
I13
sS'trials.response'
p120
I1
sg21
g22
sS'trials.intensity'
p121
g116
sg17
F0.78753381594833627
sa(dp122
g29
g30
sS'trials.stepSize'
p123
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xd9?'
tRp124
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p125
I14
sS'trials.response'
p126
I1
sg21
g22
sS'trials.intensity'
p127
g116
sg17
F0.66744788223513751
sa(dp128
g29
g30
sS'trials.stepSize'
p129
g124
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p130
I15
sS'trials.response'
p131
I1
sg21
g22
sS'trials.intensity'
p132
g24
(g26
S'd}q\x94\xda\xacD?'
tRp133
sg17
F0.64076520487560629
sa(dp134
g29
g30
sS'trials.stepSize'
p135
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp136
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p137
I16
sS'trials.response'
p138
I0
sg21
g22
sS'trials.intensity'
p139
g133
sg17
F0.76089279536881804
sa(dp140
g29
g30
sS'trials.stepSize'
p141
g136
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p142
I17
sS'trials.response'
p143
I0
sg21
g22
sS'trials.intensity'
p144
g24
(g26
S'\xf9\xa9\xf1\xd2MbP?'
tRp145
sg17
F0.54731787685614108
sa(dp146
g29
g30
sS'trials.stepSize'
p147
g136
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p148
I18
sS'trials.response'
p149
I1
sg21
g22
sS'trials.intensity'
p150
g24
(g26
S'\x9c7y\x1b\x86\xf7Y?'
tRp151
sg17
F0.62748303089938418
sa(dp152
g29
g30
sS'trials.stepSize'
p153
g136
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p154
I19
sS'trials.response'
p155
I1
sg21
g22
sS'trials.intensity'
p156
g151
sg17
F0.58732529055578198
sa(dp157
g29
g30
sS'trials.stepSize'
p158
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp159
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p160
I20
sS'trials.response'
p161
I1
sg21
g22
sS'trials.intensity'
p162
g151
sg17
F0.58740105759989092
sa(dp163
g29
g30
sS'trials.stepSize'
p164
g159
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p165
I21
sS'trials.response'
p166
I1
sg21
g22
sS'trials.intensity'
p167
g24
(g26
S'\xf9\xa9\xf1\xd2MbP?'
tRp168
sg17
F0.66742524268101988
sa(dp169
g29
g30
sS'trials.stepSize'
p170
g159
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p171
I22
sS'trials.response'
p172
I1
sg21
g22
sS'trials.intensity'
p173
g168
sg17
F0.62741752712099697
sa(dp174
g29
g30
sS'trials.stepSize'
p175
g159
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p176
I23
sS'trials.response'
p177
I1
sg21
g22
sS'trials.intensity'
p178
g168
sg17
F0.94778684768607491
sa(dp179
g29
g30
sS'trials.stepSize'
p180
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp181
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p182
I24
sS'trials.response'
p183
I0
sg21
g22
sS'trials.intensity'
p184
g24
(g26
S'd}q\x94\xda\xacD?'
tRp185
sg17
F0.86786952130296413
sa(dp186
g29
g30
sS'trials.stepSize'
p187
g181
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p188
I25
sS'trials.response'
p189
I0
sg21
g22
sS'trials.intensity'
p190
g24
(g26
S'\xf9\xa9\xf1\xd2MbP?'
tRp191
sg17
F0.95995274068445724
sa(dp192
g29
g30
sS'trials.stepSize'
p193
g181
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p194
I26
sS'trials.response'
p195
I1
sg21
g22
sS'trials.intensity'
p196
g24
(g26
S'\x9c7y\x1b\x86\xf7Y?'
tRp197
sg17
F0.57391633507268125
sa(dp198
g29
g30
sS'trials.stepSize'
p199
g181
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p200
I27
sS'trials.response'
p201
I1
sg21
g22
sS'trials.intensity'
p202
g197
sg17
F0.70743386382400786
sa(dp203
g29
g30
sS'trials.stepSize'
p204
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp205
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p206
I28
sS'trials.response'
p207
I1
sg21
g22
sS'trials.intensity'
p208
g197
sg17
F0.66989536903383851
sa(dp209
g29
g30
sS'trials.stepSize'
p210
g205
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p211
I29
sS'trials.response'
p212
I1
sg21
g22
sS'trials.intensity'
p213
g24
(g26
S'\xf9\xa9\xf1\xd2MbP?'
tRp214
sg17
F0.73423155012096686
sasS'loops'
p215
(lp216
g1
(cpsychopy.data
StairHandler
p217
g3
NtRp218
(dp219
S'origin'
p220
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.70.01), maj 18, 2016, at 11:08\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'psychophysicsStaircase'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'s_001', 'ori':10}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(3440, 1440), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instr"\u000ainstrClock = core.Clock()\u000ainstructions = visual.TextStim(win=win, ori=0, name='instructions',\u000a    text="This exp measures your detection threshold using a staircase procedure.\u005cn\u005cnPress 'up' if you see the stimulus, 'down' if you didn't.\u005cn\u005cnAny key to start",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1, 1, 1], colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000afixation = visual.GratingStim(win=win, name='fixation',units='pix', \u000a    tex=None, mask=None,\u000a    ori=0, pos=[0, 0], size=[3, 3], sf=1, phase=0.0,\u000a    color=[1, 1, 1], colorSpace='rgb', opacity=1,\u000a    texRes=128, interpolate=True, depth=0.0)\u000agabor = visual.GratingStim(win=win, name='gabor',units='pix', \u000a    tex='sin', mask='gauss',\u000a    ori=expInfo['ori'], pos=[0, 0], size=[128,128], sf=0.1, phase=1.0,\u000a    color=1.0, colorSpace='rgb', opacity=1,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr"-------\u000at = 0\u000ainstrClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aready = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aready.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrComponents = []\u000ainstrComponents.append(instructions)\u000ainstrComponents.append(ready)\u000afor thisComponent in instrComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instructions* updates\u000a    if t >= 0 and instructions.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instructions.tStart = t  # underestimates by a little under one frame\u000a        instructions.frameNStart = frameN  # exact frame index\u000a        instructions.setAutoDraw(True)\u000a    \u000a    # *ready* updates\u000a    if t >= 0 and ready.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ready.tStart = t  # underestimates by a little under one frame\u000a        ready.frameNStart = frameN  # exact frame index\u000a        ready.status = STARTED\u000a        # keyboard checking is just starting\u000a        ready.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ready.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ready.keys = theseKeys[-1]  # just the last key pressed\u000a            ready.rt = ready.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instr"-------\u000afor thisComponent in instrComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ready.keys in ['', [], None]:  # No response was made\u000a   ready.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ready.keys',ready.keys)\u000aif ready.keys != None:  # we had a response\u000a    thisExp.addData('ready.rt', ready.rt)\u000athisExp.nextEntry()\u000a# the Routine "instr" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#--------Prepare to start Staircase "trials" --------\u000a# set up handler to look after next chosen value etc\u000atrials = data.StairHandler(startVal=0.5, extraInfo=expInfo,\u000a    stepSizes=asarray([0.8,0.8,0.4,0.4,0.2]), stepType='log',\u000a    nReversals=0, nTrials=30.0, \u000a    nUp=1, nDown=3,\u000a    minVal=0.0, maxVal=1.0,\u000a    originPath=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experimentlevel = thisTrial = 0.5  # initialise some vals\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    level = thisTrial\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    gabor.setColor([level, level, level], colorSpace='rgb')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation)\u000a    trialComponents.append(gabor)\u000a    trialComponents.append(resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation* updates\u000a        if t >= 0.0 and fixation.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation.tStart = t  # underestimates by a little under one frame\u000a            fixation.frameNStart = frameN  # exact frame index\u000a            fixation.setAutoDraw(True)\u000a        if fixation.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            fixation.setAutoDraw(False)\u000a        \u000a        # *gabor* updates\u000a        if t >= 0.5 and gabor.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            gabor.tStart = t  # underestimates by a little under one frame\u000a            gabor.frameNStart = frameN  # exact frame index\u000a            gabor.setAutoDraw(True)\u000a        if gabor.status == STARTED and t >= (0.5 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            gabor.setAutoDraw(False)\u000a        if gabor.status == STARTED:  # only update if being drawn\u000a            gabor.setPhase(trialClock.getTime()*2, log=False)\u000a        \u000a        # *resp* updates\u000a        if t >= 0.5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (0.5 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str('up')) or (resp.keys == 'up'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str('up').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (StairHandler)\u000a    trials.addResponse(resp.corr)\u000a    trials.addOtherData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# staircase completed\u000a\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials')\u000awin.close()\u000acore.quit()\u000a
p221
sS'nDown'
p222
I3
sS'_exp'
p223
I84822224
sS'reversalIntensities'
p224
(lp225
F1
ag110
ag116
ag133
ag151
ag185
ag197
asS'stepSizes'
p226
cnumpy.core.multiarray
_reconstruct
p227
(cnumpy
ndarray
p228
(I0
tS'b'
tRp229
(I1
(I5
tg26
I00
S'\x9a\x99\x99\x99\x99\x99\xe9?\x9a\x99\x99\x99\x99\x99\xe9?\x9a\x99\x99\x99\x99\x99\xd9?\x9a\x99\x99\x99\x99\x99\xd9?\x9a\x99\x99\x99\x99\x99\xc9?'
tbsS'nUp'
p230
I1
sS'startVal'
p231
F0.5
sS'_nextIntensity'
p232
g214
sS'_warnUseOfNext'
p233
I01
sS'method'
p234
S'2AFC'
p235
sS'maxVal'
p236
F1
sS'stepSizeCurrent'
p237
g205
sS'correctCounter'
p238
I1
sS'nReversals'
p239
I5
sS'minVal'
p240
F0
sS'otherData'
p241
(dp242
g17
(lp243
g49
aF0.25378367331904883
aF0.49393048630372505
aF0.34714798963796056
aF0.33376922022762301
aF0.41390267889255483
aF0.40322737417955068
aF0.40061476956270781
aF0.69582097968304879
aF0.5605807317460858
aF0.56066042297970853
aF1.187563579415837
aF0.93428582468095556
aF0.78753381594833627
aF0.66744788223513751
aF0.64076520487560629
aF0.76089279536881804
aF0.54731787685614108
aF0.62748303089938418
aF0.58732529055578198
aF0.58740105759989092
aF0.66742524268101988
aF0.62741752712099697
aF0.94778684768607491
aF0.86786952130296413
aF0.95995274068445724
aF0.57391633507268125
aF0.70743386382400786
aF0.66989536903383851
aF0.73423155012096686
assS'finished'
p244
I01
sS'stepType'
p245
S'log'
p246
sS'data'
p247
(lp248
I0
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI1
aI0
aI0
aI1
aI1
aI1
aI1
aI1
aI1
aI0
aI0
aI1
aI1
aI1
aI1
asS'reversalPoints'
p249
(lp250
I1
aI11
aI14
aI16
aI20
aI24
aI28
asg6
S'C:\\Users\\Vlad Ilie\\Documents\\DemosPsyschopy\\psychophysicsStaircase\\psychophysicsStaircase.py'
p251
sg10
S'trials'
p252
sg19
g20
sS'currentDirection'
p253
S'down'
p254
sS'_variableStep'
p255
I01
sS'intensities'
p256
(lp257
F0.5
aF1
ag61
ag61
ag61
ag77
ag77
ag77
ag93
ag93
ag93
ag110
ag116
ag116
ag116
ag133
ag133
ag145
ag151
ag151
ag151
ag168
ag168
ag168
ag185
ag191
ag197
ag197
ag197
ag214
asS'initialRule'
p258
I0
sS'nTrials'
p259
F30
sS'thisTrialN'
p260
I29
sg18
I01
sbasS'savePickle'
p261
I00
sb.