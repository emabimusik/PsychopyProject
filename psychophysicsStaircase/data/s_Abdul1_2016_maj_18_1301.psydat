ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cVlad Ilie\u005cDocuments\u005cDemosPsyschopy\u005cpsychophysicsStaircase\u005cdata\u005cs_Abdul1_2016_maj_18_1301
p8
sS'runtimeInfo'
p9
NsS'name'
p10
VpsychophysicsStaircase
p11
sS'dataNames'
p12
(lp13
S'ready.keys'
p14
aS'ready.rt'
p15
aS'trials.response'
p16
aS'resp.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_maj_18_1301
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'Z\xa8n\xad\xcb\xb3R@'
tRp27
sS'expName'
p28
g11
sS'participant'
p29
Vs_Abdul1
p30
sS'ori'
p31
I10
ssS'loopsUnfinished'
p32
(lp33
sS'saveWideText'
p34
I01
sS'thisEntry'
p35
(dp36
sS'version'
p37
S''
sS'_paramNamesSoFar'
p38
(lp39
sS'entries'
p40
(lp41
(dp42
g28
g11
sg29
g30
sg15
F37.497395849055465
sg21
g22
sg14
S'lshift'
p43
sg23
g27
sg31
I10
sa(dp44
g29
g30
sS'trials.stepSize'
p45
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp46
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p47
I0
sg16
I0
sg21
g22
sS'trials.intensity'
p48
F0.5
sg17
(lp49
sa(dp50
g29
g30
sS'trials.stepSize'
p51
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p53
I1
sS'trials.response'
p54
I1
sg21
g22
sS'trials.intensity'
p55
F1
sg17
F0.97439467904405319
sa(dp56
g29
g30
sS'trials.stepSize'
p57
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p58
I2
sS'trials.response'
p59
I1
sg21
g22
sS'trials.intensity'
p60
g24
(g26
S't\xb3v\xc5`I\xc4?'
tRp61
sg17
F0.72080102922336664
sa(dp62
g29
g30
sS'trials.stepSize'
p63
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p64
I3
sS'trials.response'
p65
I1
sg21
g22
sS'trials.intensity'
p66
g61
sg17
F0.73410583472286817
sa(dp67
g29
g30
sS'trials.stepSize'
p68
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p69
I4
sS'trials.response'
p70
I1
sg21
g22
sS'trials.intensity'
p71
g61
sg17
F0.60349409621267114
sa(dp72
g29
g30
sS'trials.stepSize'
p73
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p74
I5
sS'trials.response'
p75
I1
sg21
g22
sS'trials.intensity'
p76
g24
(g26
S'\xdd\xe6\xfbr\xc2\xb8\x99?'
tRp77
sg17
F0.77417057777347509
sa(dp78
g29
g30
sS'trials.stepSize'
p79
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p80
I6
sS'trials.response'
p81
I1
sg21
g22
sS'trials.intensity'
p82
g77
sg17
F0.52058417260559509
sa(dp83
g29
g30
sS'trials.stepSize'
p84
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p85
I7
sS'trials.response'
p86
I1
sg21
g22
sS'trials.intensity'
p87
g77
sg17
F0.56067185705614975
sa(dp88
g29
g30
sS'trials.stepSize'
p89
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p90
I8
sS'trials.response'
p91
I1
sg21
g22
sS'trials.intensity'
p92
g24
(g26
S'\x84\xees\xcctNp?'
tRp93
sg17
F0.85434715411975048
sa(dp94
g29
g30
sS'trials.stepSize'
p95
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p96
I9
sS'trials.response'
p97
I1
sg21
g22
sS'trials.intensity'
p98
g93
sg17
F0.80082637343730312
sa(dp99
g29
g30
sS'trials.stepSize'
p100
g52
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p101
I10
sS'trials.response'
p102
I1
sg21
g22
sS'trials.intensity'
p103
g93
sg17
F0.78765982006734703
sa(dp104
g29
g30
sS'trials.stepSize'
p105
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xd9?'
tRp106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p107
I11
sS'trials.response'
p108
I0
sg21
g22
sS'trials.intensity'
p109
g24
(g26
S'd}q\x94\xda\xacD?'
tRp110
sg17
F1.4416162458946928
sa(dp111
g29
g30
sS'trials.stepSize'
p112
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p113
I12
sS'trials.response'
p114
I0
sg21
g22
sS'trials.intensity'
p115
g24
(g26
S'\x9b7y\x1b\x86\xf7Y?'
tRp116
sg17
F1.4281897905930236
sa(dp117
g29
g30
sS'trials.stepSize'
p118
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p119
I13
sS'trials.response'
p120
I0
sg21
g22
sS'trials.intensity'
p121
g24
(g26
S'\x84\xees\xcctNp?'
tRp122
sg17
(lp123
sa(dp124
g29
g30
sS'trials.stepSize'
p125
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p126
I14
sS'trials.response'
p127
I0
sg21
g22
sS'trials.intensity'
p128
g24
(g26
S'w\x14\xaeG\xe1z\x84?'
tRp129
sg17
(lp130
sa(dp131
g29
g30
sS'trials.stepSize'
p132
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p133
I15
sS'trials.response'
p134
I0
sg21
g22
sS'trials.intensity'
p135
g24
(g26
S'\xdb\xe6\xfbr\xc2\xb8\x99?'
tRp136
sg17
(lp137
sa(dp138
g29
g30
sS'trials.stepSize'
p139
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p140
I16
sS'trials.response'
p141
I0
sg21
g22
sS'trials.intensity'
p142
g24
(g26
S"\xf7\xa9\xf8\xc3\n'\xb0?"
tRp143
sg17
F0.1469043597135169
sa(dp144
g29
g30
sS'trials.stepSize'
p145
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p146
I17
sS'trials.response'
p147
I1
sg21
g22
sS'trials.intensity'
p148
g24
(g26
S'r\xb3v\xc5`I\xc4?'
tRp149
sg17
F0.60067139823149773
sa(dp150
g29
g30
sS'trials.stepSize'
p151
g106
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p152
I18
sS'trials.response'
p153
I1
sg21
g22
sS'trials.intensity'
p154
g149
sg17
F0.56061782401957316
sa(dp155
g29
g30
sS'trials.stepSize'
p156
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xd9?'
tRp157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p158
I19
sS'trials.response'
p159
I1
sg21
g22
sS'trials.intensity'
p160
g149
sg17
F0.614025708859117
sa(dp161
g29
g30
sS'trials.stepSize'
p162
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p163
I20
sS'trials.response'
p164
I1
sg21
g22
sS'trials.intensity'
p165
g24
(g26
S"\xf7\xa9\xf8\xc3\n'\xb0?"
tRp166
sg17
F0.61405529119292623
sa(dp167
g29
g30
sS'trials.stepSize'
p168
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p169
I21
sS'trials.response'
p170
I1
sg21
g22
sS'trials.intensity'
p171
g166
sg17
F0.46726382732595084
sa(dp172
g29
g30
sS'trials.stepSize'
p173
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p174
I22
sS'trials.response'
p175
I1
sg21
g22
sS'trials.intensity'
p176
g166
sg17
F0.44044713999028318
sa(dp177
g29
g30
sS'trials.stepSize'
p178
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p179
I23
sS'trials.response'
p180
I1
sg21
g22
sS'trials.intensity'
p181
g24
(g26
S'\xdc\xe6\xfbr\xc2\xb8\x99?'
tRp182
sg17
F0.48058734817823279
sa(dp183
g29
g30
sS'trials.stepSize'
p184
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p185
I24
sS'trials.response'
p186
I1
sg21
g22
sS'trials.intensity'
p187
g182
sg17
F0.44057935491218814
sa(dp188
g29
g30
sS'trials.stepSize'
p189
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p190
I25
sS'trials.response'
p191
I1
sg21
g22
sS'trials.intensity'
p192
g182
sg17
F0.37379995339142624
sa(dp193
g29
g30
sS'trials.stepSize'
p194
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p195
I26
sS'trials.response'
p196
I1
sg21
g22
sS'trials.intensity'
p197
g24
(g26
S'x\x14\xaeG\xe1z\x84?'
tRp198
sg17
F0.69407671121734893
sa(dp199
g29
g30
sS'trials.stepSize'
p200
g157
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p201
I27
sS'trials.response'
p202
I1
sg21
g22
sS'trials.intensity'
p203
g198
sg17
F1.2147185391877429
sa(dp204
g29
g30
sS'trials.stepSize'
p205
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp206
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p207
I28
sS'trials.response'
p208
I0
sg21
g22
sS'trials.intensity'
p209
g198
sg17
F0.8275808774997131
sa(dp210
g29
g30
sS'trials.stepSize'
p211
g206
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p212
I29
sS'trials.response'
p213
I1
sg21
g22
sS'trials.intensity'
p214
g24
(g26
S'\xc2\xc2+\xd1\xb3:\x90?'
tRp215
sg17
F0.60072814801242203
sa(dp216
g29
g30
sS'trials.stepSize'
p217
g206
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p218
I30
sS'trials.response'
p219
I1
sg21
g22
sS'trials.intensity'
p220
g215
sg17
F0.58931993233636604
sa(dp221
g29
g30
sS'trials.stepSize'
p222
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp223
sg31
I10
sg23
g27
sg28
g11
sS'trials.thisTrialN'
p224
I31
sS'trials.response'
p225
I1
sg21
g22
sS'trials.intensity'
p226
g215
sg17
F0.46733476455483469
sasS'loops'
p227
(lp228
g1
(cpsychopy.data
StairHandler
p229
g3
NtRp230
(dp231
S'origin'
p232
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.70.01), maj 16, 2016, at 12:47\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'psychophysicsStaircase'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'s_001', 'ori':10}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(3440, 1440), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instr"\u000ainstrClock = core.Clock()\u000ainstructions = visual.TextStim(win=win, ori=0, name='instructions',\u000a    text="This exp measures your detection threshold using a staircase procedure.\u005cn\u005cnPress 'up' if you see the stimulus, 'down' if you didn't.\u005cn\u005cnAny key to start",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1, 1, 1], colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000afixation = visual.GratingStim(win=win, name='fixation',units='pix', \u000a    tex=None, mask=None,\u000a    ori=0, pos=[0, 0], size=[3, 3], sf=1, phase=0.0,\u000a    color=[1, 1, 1], colorSpace='rgb', opacity=1,\u000a    texRes=128, interpolate=True, depth=0.0)\u000agabor = visual.GratingStim(win=win, name='gabor',units='pix', \u000a    tex='sin', mask='gauss',\u000a    ori=expInfo['ori'], pos=[0, 0], size=[128,128], sf=0.1, phase=1.0,\u000a    color=1.0, colorSpace='rgb', opacity=1,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr"-------\u000at = 0\u000ainstrClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aready = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aready.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrComponents = []\u000ainstrComponents.append(instructions)\u000ainstrComponents.append(ready)\u000afor thisComponent in instrComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instructions* updates\u000a    if t >= 0 and instructions.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instructions.tStart = t  # underestimates by a little under one frame\u000a        instructions.frameNStart = frameN  # exact frame index\u000a        instructions.setAutoDraw(True)\u000a    \u000a    # *ready* updates\u000a    if t >= 0 and ready.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ready.tStart = t  # underestimates by a little under one frame\u000a        ready.frameNStart = frameN  # exact frame index\u000a        ready.status = STARTED\u000a        # keyboard checking is just starting\u000a        ready.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ready.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ready.keys = theseKeys[-1]  # just the last key pressed\u000a            ready.rt = ready.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instr"-------\u000afor thisComponent in instrComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ready.keys in ['', [], None]:  # No response was made\u000a   ready.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ready.keys',ready.keys)\u000aif ready.keys != None:  # we had a response\u000a    thisExp.addData('ready.rt', ready.rt)\u000athisExp.nextEntry()\u000a# the Routine "instr" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#--------Prepare to start Staircase "trials" --------\u000a# set up handler to look after next chosen value etc\u000atrials = data.StairHandler(startVal=0.5, extraInfo=expInfo,\u000a    stepSizes=asarray([0.8,0.8,0.4,0.4,0.2]), stepType='log',\u000a    nReversals=0, nTrials=30.0, \u000a    nUp=1, nDown=3,\u000a    minVal=0.0, maxVal=1.0,\u000a    originPath=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experimentlevel = thisTrial = 0.5  # initialise some vals\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    level = thisTrial\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    gabor.setColor([level, level, level], colorSpace='rgb')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation)\u000a    trialComponents.append(gabor)\u000a    trialComponents.append(resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation* updates\u000a        if t >= 0.0 and fixation.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation.tStart = t  # underestimates by a little under one frame\u000a            fixation.frameNStart = frameN  # exact frame index\u000a            fixation.setAutoDraw(True)\u000a        if fixation.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            fixation.setAutoDraw(False)\u000a        \u000a        # *gabor* updates\u000a        if t >= 0.5 and gabor.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            gabor.tStart = t  # underestimates by a little under one frame\u000a            gabor.frameNStart = frameN  # exact frame index\u000a            gabor.setAutoDraw(True)\u000a        if gabor.status == STARTED and t >= (0.5 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            gabor.setAutoDraw(False)\u000a        if gabor.status == STARTED:  # only update if being drawn\u000a            gabor.setPhase(trialClock.getTime()*2, log=False)\u000a        \u000a        # *resp* updates\u000a        if t >= 0.5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (0.5 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str('up')) or (resp.keys == 'up'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str('up').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (StairHandler)\u000a    trials.addResponse(resp.corr)\u000a    trials.addOtherData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# staircase completed\u000a\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials')\u000awin.close()\u000acore.quit()\u000a
p233
sS'nDown'
p234
I3
sS'_exp'
p235
I87632208
sS'reversalIntensities'
p236
(lp237
F1
ag110
ag149
ag198
ag215
asS'stepSizes'
p238
cnumpy.core.multiarray
_reconstruct
p239
(cnumpy
ndarray
p240
(I0
tS'b'
tRp241
(I1
(I5
tg26
I00
S'\x9a\x99\x99\x99\x99\x99\xe9?\x9a\x99\x99\x99\x99\x99\xe9?\x9a\x99\x99\x99\x99\x99\xd9?\x9a\x99\x99\x99\x99\x99\xd9?\x9a\x99\x99\x99\x99\x99\xc9?'
tbsS'nUp'
p242
I1
sS'startVal'
p243
F0.5
sS'_nextIntensity'
p244
g24
(g26
S'x\x14\xaeG\xe1z\x84?'
tRp245
sS'_warnUseOfNext'
p246
I01
sS'method'
p247
S'2AFC'
p248
sS'maxVal'
p249
F1
sS'stepSizeCurrent'
p250
g223
sS'correctCounter'
p251
I0
sS'nReversals'
p252
I5
sS'minVal'
p253
F0
sS'otherData'
p254
(dp255
g17
(lp256
g49
aF0.97439467904405319
aF0.72080102922336664
aF0.73410583472286817
aF0.60349409621267114
aF0.77417057777347509
aF0.52058417260559509
aF0.56067185705614975
aF0.85434715411975048
aF0.80082637343730312
aF0.78765982006734703
aF1.4416162458946928
aF1.4281897905930236
ag123
ag130
ag137
aF0.1469043597135169
aF0.60067139823149773
aF0.56061782401957316
aF0.614025708859117
aF0.61405529119292623
aF0.46726382732595084
aF0.44044713999028318
aF0.48058734817823279
aF0.44057935491218814
aF0.37379995339142624
aF0.69407671121734893
aF1.2147185391877429
aF0.8275808774997131
aF0.60072814801242203
aF0.58931993233636604
aF0.46733476455483469
assS'finished'
p257
I01
sS'stepType'
p258
S'log'
p259
sS'data'
p260
(lp261
I0
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI0
aI0
aI0
aI0
aI0
aI0
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI1
asS'reversalPoints'
p262
(lp263
I1
aI11
aI19
aI28
aI31
asg6
S'C:\\Users\\Vlad Ilie\\Documents\\DemosPsyschopy\\psychophysicsStaircase\\psychophysicsStaircase.py'
p264
sg10
S'trials'
p265
sg19
g20
sS'currentDirection'
p266
S'down'
p267
sS'_variableStep'
p268
I01
sS'intensities'
p269
(lp270
F0.5
aF1
ag61
ag61
ag61
ag77
ag77
ag77
ag93
ag93
ag93
ag110
ag116
ag122
ag129
ag136
ag143
ag149
ag149
ag149
ag166
ag166
ag166
ag182
ag182
ag182
ag198
ag198
ag198
ag215
ag215
ag215
asS'initialRule'
p271
I0
sS'nTrials'
p272
F30
sS'thisTrialN'
p273
I31
sg18
I01
sbasS'savePickle'
p274
I00
sb.